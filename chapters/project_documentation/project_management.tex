\chapter{Project Management}\label{project-management}

\section{Milestones}

\paragraph{START}
Getting familiar with tools and topic.

\paragraph{ALPHA}
Create a proof of concept tileserver.

\paragraph{BETA}
Rendering switzerland.

\paragraph{PREFINAL}
Good looking lower tiles.

\paragraph{FINAL}
Rendering.

\section{Releases}

\paragraph{v0.1 BETA}
Tooling of entire workflow to render switzerland.

\paragraph{v0.2 PREFINAL}
Used for initial rendering.

\paragraph{v1 FINAL}
Included lessons learned from v0.2

\section{Roles and Responsibilities}\label{roles-and-responsibilities}

\paragraph{Stefan Keller}
Thesis advisor responsible for supervising the work.

\paragraph{Petr Pridal}
Technical partner responsible for providing infrastructure and guidance
in technical and map relatec questions.

\paragraph{Manuel Roth}
Contributor responsible for data style and JavaScript tooling.

\paragraph{Lukas Martinelli}
Contributor responsible for rendering infrastructure and Python scripts.

\section{Aufwandsch√§tzung, Zeitplan, Projektplan}

\section{Risks}\label{risks}

\section{Prozessmodell}

We used GitHub for planning and tracking the tasks.

Our sprints are organized into milestones and tasks were assigned to a milestone

Managing tickets, milestones and progress all happens on the public
GitHub repository.



There are two GitHub repositories:

\begin{itemize}
\item
  \textbf{osm2vectortile} contains the project
\item
  \textbf{osm2vectortile-thesis} contains the thesis
\end{itemize}

%---------------------------------------------------------------
\newpage
\chapter{Quality Measures}\label{quality-measures}

\section{Testing}\label{testing}

Our ecosystem is quite a diverse one with a big collection of small
tools that all work together. Therefore we use high level integration
tests to ensure that our components work together.

\section{Guidelines}\label{guidelines}
To have a homogenous software we settled on common guidelines in 
the beginning of the project.

\subsection{Releases}
We use semantic versioning \footnote{\url{http://semver.org/}}. At the
end of each milestone a new release will be created.

\subsection{Git}\label{git}
\paragraph{Commit Messages}
We use the seven rules of great git commit
messages\footnote{\url{http://chris.beams.io/posts/git-commit/}}.

\paragraph{Rewriting}
Git history should be kept clean and therefore local branches should be
squashed meaningfully.

\paragraph{Pulling}
To avoid unnecessary merge messages one should always use the
\texttt{-\/-rebase} parameter.

\subsection{Workflow}\label{workflow}
We use the Feature Branch Workflow\footnote{\url{https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow/}}.

Every project member has a local repository with a copy of the remote
repository. For each feature ticket in GitHub a separate branch
will be created. Once a ticket has been completed a pull request will be
created and needs to be merged into the \texttt{master} branch by an other 

\subsection{Coding Standards}

\paragraph{Bash} We use Bash for our Docker image entrypoints and follow
the rules of Defensive Bash Programming \footnote{\url{http://www.kfirlavi.com/blog/2012/11/14/defensive-bash-programming/}}.

\paragraph{Python} For Python code we want to stay PEP-8\footnote{\url{https://www.python.org/dev/peps/pep-0008/}} compliant and write idiomatic Python code according to PEP-20\footnote{\url{https://www.python.org/dev/peps/pep-0020/}}.

\paragraph{JavaScript}


\paragraph{SQL} Our PostgreSQL code is using upper case for the key words. Apart from that we try to have nice formatted SQL code and use functions
if necessary to keep the queries DRY\footnote{\url{https://en.wikipedia.org/w/index.php?title=Don%27t_repeat_yourself&oldid=691047461}}.

\paragraph{Dockerfile} Dockerfiles follow the best practices\footnote{\url{https://docs.docker.com/engine/articles/dockerfile\_best-practices/}} defined by Docker.

%---------------------------------------------------------------