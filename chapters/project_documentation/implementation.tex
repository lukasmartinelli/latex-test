\chapter{Implementation}\label{implementation}

The most promising vector tile specification was proposed by Mapbox.
\marginpar{The Mapbox Vector Tile Specification is compared with other vector tile formats in chapter \ref{vector-tile-formats}}
They provide many open source tools to manage vector tiles. We tried not to implement tools which already exists and instead use as many existing tools as possible. Because of this our implementation consists mostly of docker containers which do a specific task.

\section{Workflow}\label{workflow}
This section describes the workflow of generating vector tiles. The following sections will provide implementation details on each of the steps described here. 

\paragraph{First step: Getting OSM data}

There are many different sources available to get OSM data from. Most of
the time Geofabrik\footnote{\url{http://download.geofabrik.de/}} was
referenced for getting single countries, continents or even the whole
planet. But many times people only need a single city or region, because
of this demand
Mapzen\footnote{\url{https://mapzen.com/data/metro-extracts/}} provides
OSM data for many cities and regions around the globe.

The OSM data is missing something very important: the administrative
boundaries. This needs to be downloaded separatly due to the fact, that
somebody could manipulate the boundary of a region. As a result of this
administrative boundaries get checked by the OSM community and released
separatly.

The data is available in the PBF and OSM XML format. If available the
PBF(Protocolbuffer Binary
Format)\footnote{\url{http://wiki.openstreetmap.org/wiki/PBF_Format}}
version should be choosen, as it is 30\% smaller and 5-6 times faster to
read and write than the bzipped OSM XML version.

\paragraph{Second step: Importing OSM data into PostGIS}
We use imposm3 to import the OSM data into our PostGIS database. Since we don't need all the key, value pairs, we defined an import mapping which defines all the values we need in the database.

\paragraph{Third step: Mapbox studio source project}

A Mapbox studio source project is divided into the following folder
structure\footnote{\url{https://www.mapbox.com/guides/source-manual/\#source-project}}:

\begin{verbatim}
source-project.tm2source/
    data.yml
    data.xml
    .thumb.png
\end{verbatim}

The data file defines all feature sets(layers) like landuse, waterway,
road etc. The definition contains metadata like id, datasource(db, host,
query, srid, extent), description, fields and properties. Mapbox Studio
needs the yml version and mapnik the xml version of this file.
.thumb.png is a thumbnail image that gets displayed in the projects
list.

\paragraph{Fourth step: Generating vector tiles}

To generate the vector tiles we use mapnik. Mapbox provides a very handy
tool to generate vector tiles.

tilelive-copy provides the Mapnik XML file and the extent to mapnik
which then generates the vector tiles. Tilelive-copy outputs these
vector tiles in the mbtiles container.
\newpage


\section{Classification}
\label{classification}

The OpenStreetMap tagging schema has developed into a complex taxonomy of real-world feature classes and objects. \cite[p. 15]{haklay2008openstreetmap}. Map designers don't want to design
for each distinct object specifically which is why Mapbox and others abstract distinct key value pairs into so called feature classes.

Mapbox calls those feature class simply class.

Mapping created key value pairs into categories cannot be automated
and there is no standard. This is why we have done it by hand.

A map designer that wants to style agricultural areas does not care
what type of field it is.

\begin{table}[]
\centering
\caption{My caption}
\label{my-label}
\begin{tabular}{llll}
Key      & Value      & Class       & Type           \\
landuse  & farm       & agriculture & orchard        \\
building & farm       & agriculture & farm           \\
landuse  & farmland   & agriculture & farmland       \\
landuse  & farmyard   & agriculture & farmyard       \\
landuse  & allotments & agriculture & allotments     \\
landuse  & vineyard   & agriculture & vineyard       \\
landuse  & vineyard   & agriculture & plant\_nursery
\end{tabular}
\end{table}

\subsection{Classification Format}

We created the classifications in a YAML based format.
Where each key in \texttt{classifications} denotes the classification name. The elements within each classification (e.g. \texttt{driveway} or \texttt{main} are the class name and the values below the class name (e.g. \texttt{primary}, \texttt{primary\_link} the OSM values to match. We do not explicitly match the OSM keys as well - only the values.

\begin{yamlcode}
classifications:
  road:
    highway:
    - motorway
    - motorway_link
    - driveway
    main:
    - primary
    - primary_link
    - trunk
    - trunk_link
    - secondary
    - secondary_link
    - tertiary
    - tertiary_link
\end{yamlcode}

\subsection{Code Generation}

We take the readable classification format and generate immutable SQL
functions we can use in our queries.
The example above will result in the following function.

\begin{sqlcode}
CREATE OR REPLACE FUNCTION classify_road(type VARCHAR)
RETURNS VARCHAR AS $$
  BEGIN
    RETURN CASE
      WHEN type IN ('motorway','motorway_link','driveway') THEN 'highway'
      WHEN type IN ('primary','primary_link',
                    'trunk','trunk_link',
                    'secondary','secondary_link',
                    'tertiary','tertiary_link') THEN 'main'
    END;
  END;
$$ LANGUAGE plpgsql IMMUTABLE;
\end{sqlcode}

\subsection{Use in Vector Tile Generation}

Classifications are then baked into vector tile attributes
of geometries.

\begin{sqlcode}
SELECT
  geometry,
  classify_road(type) AS class,
  type AS type
FROM osm_roads
\end{sqlcode}

\section{Relative Importance}
\label{localrank}

To reduce label density on lower zoom levels but still contain all data in e.g. zoom level 14 the \texttt{localrank} attribute indiciates how
important a label is compared to the labels in its neighbourhood.

\subsection{Calculating Rank}

And then create the local rank for each tile in a 128 px grid when returning the POIs.

In the best case scenario one would create a function that
ranks each individual point of interest. In this case we only ranked the most important features.

\subsubsection{Order Features by their Types}

\begin{sqlcode}
CREATE OR REPLACE FUNCTION localrank_poi(type VARCHAR) RETURNS INTEGER
AS $$
BEGIN
  RETURN CASE
    WHEN type IN ('station', 'subway_entrance', 'park',
                  'cemetery', 'bank', 'supermarket', 'car',
                  'library', 'university', 'college', 'police',
                  'townhall', 'courthouse') THEN 2
    WHEN type IN ('nature_reserve', 'garden', 'public_building') THEN 3
    WHEN type IN ('stadium') THEN 90
    WHEN type IN ('hospital') THEN 100
    WHEN type IN ('zoo') THEN 200
    WHEN type IN ('university', 'school', 'college', 'kindergarten') THEN 300
    WHEN type IN ('supermarket', 'department_store') THEN 400
    WHEN type IN ('nature_reserve', 'swimming_area') THEN 500
    WHEN type IN ('attraction') THEN 600
    ELSE 1000
  END;
END;
$$ LANGUAGE plpgsql IMMUTABLE;
\end{sqlcode}


\subsubsection{Calculate Rank of Features}

The rank is calculated across a grid of 128 pixels. Our most
important features from the \texttt{localrank\_poi} function will
also be the most relevant POIs.

\begin{sqlcode}
SELECT
  geometry,
  rank() OVER (PARTITION BY LabelGrid(geometry, 128 * !pixel_width!)
               ORDER BY localrank_poi(type) ASC) AS localrank,
FROM osm_poi
\end{sqlcode}

\section{Data Style}\label{data_style}

The data style is a description of all the feature classes such as landuse, water or roads. This description was invented by Mapbox.

The format of a data style looks like this:
\begin{yamlcode}
_prefs: 
  disabled: []
  inspector: false
  mapid: ''
  rev: ''
  saveCenter: true
attribution: ''
center: 
  - 21.7969
  - 34.6694
  - 3
description: Open Streets
Layer: 
    # All layer definitions come here
maxzoom: 14
minzoom: 0
name: Open Streets
\end{yamlcode}

\subsection{Layer Definition}\label{layer_definition}
A layer definition describes a view on the data. It can consist of multiple data sources. In the figure below the layer is a view and the definition of this view is a graphic definition.

\begin{figure}[h]
  \centering
  \includegraphics[width=1\textwidth]{images/graphic_definition.png}
  \caption{General graphic definition}
\end{figure}

A layer definition looks like this:
\begin{yamlcode}
- id: landuse
Datasource:
    extent: -20037508.34,-20037508.34,20037508.34,20037508.34
    host: db
    port: 5432
    user: osm
    password: osm
    dbname: osm
    key_field: osm_id
    table: |-
        (
            SELECT osm_id, class, type, geometry
            FROM osm_landusages
            WHERE geometry && !bbox!
            AND z(!scale_denominator!) > 5
        
        ) as data
    type: postgis
fields:
    osm_id: Number
    class: String
    type: String
properties:
    "buffer-size": 4
\end{yamlcode}
The layer definition consist of the id (layername), datasource, fields and the properties. The datasource in this case defines how the postgis database can be accessed and which sql query needs to be executed. But the datasource could also be a geojson, shapefile, sqlite database, geotiff, kml, gpx or csv file.


\subsubsection{Buffers}\label{buffers}
The buffer value on a layer defines how many pixels around each tile will be included. It is necessary to ensure correct rendering across tile boundaries. This value is individual for each layer and depends on the type of data. Buffers for layers containing labels should have a large buffers size such as 128 pixels, whereas a layer like landuse does only need a buffers size of 4 pixels. In general, the buffer size should be set to the minimum to keep the size of the vector tiles as low as possible.\footnote{\url{https://www.mapbox.com/help/source-manual/\#buffers}}

\begin{figure}[h]
  \centering
  \includegraphics[width=1\textwidth]{images/buffer.png}
  \caption{Example for buffer values}
\end{figure}

The figure above is a good example to see the result of a buffer value. We can see that there are rivers but no other data, therefore the rivers must have a larger buffer value that the other layers.

\subsubsection{Overzooming}\label{overzooming}
The min- and maxzoom values define on which zoom levels there is data. This does not mean that it is not possible to zoom deeper in that the maxzoom value.
Overzooming defines to term of displaying data at higher zoom levels.\footnote{\url{https://www.mapbox.com/help/source-manual/\#overzooming}}
This allows us to show data on higher zoom levels, without generating vector tiles for these zoom levels.
Mapbox has defined a rule of thumb for vector tiles. Vector tiles are useful for about 4-6 levels of overzooming. If I have a vector tile on zoom level 10, it can be stretched out up to zoom level 14 or 16.  

\subsubsection{Layer Ordering}\label{layer_ordering}
The order in which the layer are defined in the data style is equal to the order they are stored in the vector tiles.
The layer at the top of the layer definition will be drawn first next the second layer and so one. So the layer at the bottom is drawn on top of all the other layers. 


\section{Zoom Level Reference}\label{zoomlevel_reference}
The zoom level reference helps to see which feature class is included on which zoom level. The zoom levels are ordered by how they get drawn. The feature class landuse is at the bottom and housenum\_label is on top of all the others. 

% Please add the following required packages to your document preamble:
% \usepackage{graphicx}
\begin{table}[H]
\centering
\resizebox{\textwidth}{!}{%
\begin{tabular}{l|ccccccccccccccc}
 & \multicolumn{1}{l}{z0} & \multicolumn{1}{l}{z1} & \multicolumn{1}{l}{z2} & \multicolumn{1}{l}{z3} & \multicolumn{1}{l}{z4} & \multicolumn{1}{l}{z5} & \multicolumn{1}{l}{z6} & \multicolumn{1}{l}{z7} & \multicolumn{1}{l}{z8} & \multicolumn{1}{l}{z9} & \multicolumn{1}{l}{z10} & \multicolumn{1}{l}{z11} & \multicolumn{1}{l}{z12} & \multicolumn{1}{l}{z13} & \multicolumn{1}{l}{z14} \\ \hline
landuse &  &  &  &  &  & x & x & x & x & x & x & x & x & x & x \\
waterway &  &  &  &  &  &  &  &  & x & x & x & x & x & x & x \\
water & x & x & x & x & x & x & x & x & x & x & x & x & x & x & x \\
aeroway &  &  &  &  &  &  &  &  &  &  &  &  & x & x & x \\
barrier\_line &  &  &  &  &  &  &  &  &  &  &  &  &  &  & x \\
building &  &  &  &  &  &  &  &  &  &  &  &  &  & x & x \\
landuse\_overlay &  &  &  &  &  &  &  & x & x & x & x & x & x & x & x \\
tunnel &  &  &  &  &  &  &  &  &  &  &  & x & x & x & x \\
road &  &  &  &  &  & x & x & x & x & x & x & x & x & x & x \\
bridge &  &  &  &  &  &  &  &  &  &  &  &  & x & x & x \\
admin & x & x & x & x & x & x & x & x & x & x & x & x & x & x & x \\
country\_label &  & x & x & x & x & x & x & x & x & x & x & x & x & x & x \\
marine\_label &  & x & x & x & x & x & x & x & x & x & x & x & x & x & x \\
state\_label &  &  &  &  & x & x & x & x & x & x & x & x & x & x & x \\
place\_label &  &  &  &  & x & x & x & x & x & x & x & x & x & x & x \\
water\_label &  &  &  &  &  &  &  &  &  &  & x & x & x & x & x \\
poi\_label &  &  &  &  &  &  &  &  &  &  &  &  &  &  & x \\
road\_label &  &  &  &  &  &  &  &  & x & x & x & x & x & x & x \\
waterway\_label &  &  &  &  &  &  &  &  & x & x & x & x & x & x & x \\
housenum\_label &  &  &  &  &  &  &  &  &  &  &  &  &  &  & x
\end{tabular}
}
\caption{Shows which feature class is included on which zoom level}
\label{my-label}
\end{table}

\section{Reverse Engineering Process}\label{reverse_engineering_process}
One of the main requirements of this project was to make our vector tiles compatible with the Mapbox Streets vector tiles\footnote{\url{https://www.mapbox.com/developers/vector-tiles/mapbox-streets-v6/}}.

We didn't define this requirement from the beginning, it just evolved during the construction of our first prototype.
Therefore we spent a lot of time making our vector tiles as similar as possible to the ones of Mapbox.

The sections below describe the tools and methods we used to achieve the goal of Mapbox Streets compatibility.

\subsection{Vector Tile Format}\label{vector_tile_format}
To better understand what the vector tile compare tool does, we will give a high level introduction to the vector tiles format.

A vector tile can consist of one or more named layers and containing one or more features. A feature consist of attributes and a geometry (point, linestring or polygon). Attributes are represented as a dictionary of key, value pairs. 

Below you can find an example vector tile, which has two layers water and admin. The water layer has the attribute key "osm\_id" and value 0. If you would compare this example with the specification\footnote{\url{https://github.com/mapbox/vector-tile-spec/tree/master/1.0.1}}, one could think this is not a specification conform vector tile. The example below is a compressed vector tile. More information on what compression methods are applied can be found in the specification. 

Mapbox Streets v6 vector tile(0/0/0):
\begin{jsoncode}
{ 
  "layers": {
    "water": {
      "version": 1,
      "name": "water",
      "extent": 4096,
      "length": 18,
      "_pbf": {
        "buf": [26,143,32,10,5,119,97,1],
        "pos": 51410,
        "length": 51410
      },
      "_keys": ["osm_id"],
      "_values": [0],
      "_features": [11,3474,3499,3530,3561,3584] 
    },
    "admin": {
      "version": 1,
      "name": "admin",
      "extent": 4096,
      "length": 1447,
      "_pbf": {
        "buf": [26,143,32,10,5,1],
        "pos":51410,
        "length":51410
       },
      "_keys": ["admin_level","disputed","iso_3166_1","maritime"],
      "_values": [2,0,"FR",1],
      "_features": [4126,4152,4377,4403,4429,4455,4481,4507,4533]
    }
  } 
}
\end{jsoncode}

\subsection{Tools}\label{tools}
During the prototyping phase we realized, that we needed build tools which help us track the progress of compatibility.

\subsubsection{Vector Tile Compare}\label{vector_tile_compare}
The vector tile compare tool analyzes vector tiles and outputs interesting information like layers and attributes. We generated this output for the same vector tiles of Mapbox Streets and our own (Open Streets). Next we uploaded the results to a Github repository and used the branch compare feature to compare them. 

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{images/vector_tile_compare.png}
  \caption{Compare of Mapbox Streets v6 and Open Streets on 31.10.2015}
\end{figure}

This gave us a good indicator, which layers are shown on which zoom level and what attributes are contained in a layer.
\subsubsection{Visual Compare}\label{visual_compare}
The vector tile comparison was good to ensure that we have exactly the same data on the same zoom level. But when we started to visually compare our map with the map of Mapbox Streets, we still saw big differences. So we decided to build a visual compare tool. 

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{images/visual_compare.png}
  \caption{Visual Compare of Mapbox Streets and Open Streets}
\end{figure}

The figure below shows a screenshot of the visual compare tool. On the left side is Mapbox Streets and on the right side our Open Streets map. They both use the same visual style (OSM Bright 2\footnote{\url{https://github.com/mapbox/mapbox-studio-osm-bright.tm2}}). When you zoom in on the right side of the map, it automatically zooms in on the right side. This tools was very helpful to find all the differences.

\subsection{Working Methods}
This section describes what we did, when we found a difference. When we identified a difference with the vector compare or visual compare tool, we first checked if the missing data is included in our import mapping. If this was not the case, we used the TagFinder tool\footnote{\url{https://wiki.openstreetmap.org/wiki/TagFinder}} find the right OSM key, value pair of the missing item. Next we included the key, value pair into our import mapping and re-imported the OSM data. At the end the SQL query needs to be altered to fetch the added item. Now the missing item should appear on the map. During this process we used mostly Mapbox Studio Classic\footnote{\url{https://www.mapbox.com/mapbox-studio-classic/}} as the map can be rendered on the fly after the query has been altered.

\section{Data Sources}
\label{data-sources}

Making a global map involves finding the right data slice in the right data sources.

\subsection{Map Features from OpenStreetMap}

The cornerstone of the entire map is \osm data from published snapshots from OSM Planet\footnote{\url{http://planet.osm.org/}}. The \osm{} data is used for high zoom levels where detailled coverage of local areas is very important.

We import selected tags \footnote{\url{http://wiki.openstreetmap.org/wiki/Tags}} and their geometries. The decision which tags and geometries are imported is in the chapter mapping

TODO: Create label for mapping

\subsection{Curated water polygons from OpenStreetMapData}

Certain OpenStreetMap data like borders and land polygons are very sensitive for change.
The OpenStreetMapData\footnote{\url{http://openstreetmapdata.com/}}
project takes care of alot of issues that happen with coastlines
and provide it in a convenient format.

We use water polygons \footnote{\url{http://openstreetmapdata.com/data/water-polygons}} from OpenStreetMapData. This data set ensures that the water polygons
work well together with other \osm{} data and splits big water polygons into multiple 
pieces for performance.

\section{Borders and ranks from Natural Earth}

The Natural Earth \footnote{\url{http://www.naturalearthdata.com/}} dataset provides manually curated data of cultural and physical features of the world. Natural earth data is especially useful at higher levels when it matters alot what should not be displayed.

We use the following data from Natural Earth:

\begin{itemize}
\item Label ranks of big cities\footnote{\url{http://www.naturalearthdata.com/downloads/10m-cultural-vectors/10m-populated-places/}}
\item Major lakes\footnote{\url{http://www.naturalearthdata.com/downloads/10m-physical-vectors/10m-lakes/}}
\item Country\footnote{\url{http://www.naturalearthdata.com/downloads/10m-cultural-vectors/10m-admin-0-countries/}} and administrative\footnote{\url{http://www.naturalearthdata.com/downloads/10m-cultural-vectors/10m-admin-1-states-provinces/}} borders including disputed borders\footnote{\url{http://www.naturalearthdata.com/downloads/10m-cultural-vectors/10m-admin-0-breakaway-disputed-areas/}}
\end{itemize}


\section{PostgreSQL Performance}
\label{postgres-performance}

The most intensive work is done on the database side to respond to all SQL queries
made by Mapnik in the fastest way possible.

\subsection{Tuning}

The PostgreSQL default parameters do not deliver good performance for stronger machines\footnote{\url{https://wiki.postgresql.org/wiki/Tuning_Your_PostgreSQL_Server}-}
For the different database machines we used the PgTune\footnote{\url{http://pgtune.leopard.in.ua/}} calculator to determine good cache and buffer sizes for data warehouse style computing.

Example configuration for a host with 50 GB of memory.

\begin{bashcode}
max_connections = 20
shared_buffers = 12800MB
effective_cache_size = 38400MB
work_mem = 320MB
maintenance_work_mem = 2GB
checkpoint_segments = 128
checkpoint_completion_target = 0.9
wal_buffers = 16MB
default_statistics_target = 500
\end{bashcode}

For speed up importing we disabled transactional features of PostgreSQL. \footnote{\url{http://www.databasesoup.com/2015/02/running-with-scissors-mode.html}}.

\begin{bashcode}
bgwriter_lru_maxpages = 0
wal_level = minimal
fsync = off
synchronous_commit = off
full_page_writes = off
wal_log_hints = off
\end{bashcode}


\subsection{Indizes}

We use clustered indizes on the geometries to provide fast tile lookup.