\chapter{Implementation}\label{implementation}

The most promising vector tile specification was proposed by Mapbox.
\marginpar{The Mapbox Vector Tile Specification is compared with other vector tile formats in chapter \ref{vector-tile-formats}}
They provide many open source tools to manage vector tiles. We tried not to implement tools which already exists and instead use as many existing tools as possible. Because of this our implementation consists mostly of docker containers which do a specific task.

\section{Data Style}\label{data_style}

The data style is a description of all the feature classes such as landuse, water or roads. This description was invented by Mapbox.

The format of a data style looks like this:
\begin{yamlcode}
_prefs: 
  disabled: []
  inspector: false
  mapid: ''
  rev: ''
  saveCenter: true
attribution: ''
center: 
  - 21.7969
  - 34.6694
  - 3
description: Open Streets
Layer: 
    # All layer definitions come here
maxzoom: 14
minzoom: 0
name: Open Streets
\end{yamlcode}

\newpage
\subsection{Layer Definition}\label{layer_definition}
A layer definition describes a view on the data. It can consist of multiple data sources. In the figure below the layer is a view and the definition of this view is a graphic definition.

\begin{figure}[h]
  \centering
  \includegraphics[width=1\textwidth]{images/graphic_definition.png}
  \caption{General graphic definition}
\end{figure}

A layer definition looks like this:
\begin{yamlcode}
- id: landuse
Datasource:
    extent: -20037508.34,-20037508.34,20037508.34,20037508.34
    host: db
    port: 5432
    user: osm
    password: osm
    dbname: osm
    key_field: osm_id
    table: |-
        (
            SELECT osm_id, class, type, geometry
            FROM osm_landusages
            WHERE geometry && !bbox!
            AND z(!scale_denominator!) > 5
        
        ) as data
    type: postgis
fields:
    osm_id: Number
    class: String
    type: String
properties:
    "buffer-size": 4
\end{yamlcode}
The layer definition consist of the id (layername), datasource, fields and the properties. The datasource in this case defines how the postgis database can be accessed and which sql query needs to be executed. But the datasource could also be a geojson, shapefile, sqlite database, geotiff, kml, gpx or csv file.


\subsubsection{Buffers}\label{buffers}
The buffer value on a layer defines how many pixels around each tile will be included. It is necessary to ensure correct rendering across tile boundaries. This value is individual for each layer and depends on the type of data. Buffers for layers containing labels should have a large buffers size such as 128 pixels, whereas a layer like landuse does only need a buffers size of 4 pixels. In general, the buffer size should be set to the minimum to keep the size of the vector tiles as low as possible.\footnote{\url{https://www.mapbox.com/help/source-manual/\#buffers}}

\begin{figure}[h]
  \centering
  \includegraphics[width=1\textwidth]{images/buffer.png}
  \caption{Example for buffer values}
\end{figure}

The figure above is a good example to see the result of a buffer value. We can see that there are rivers but no other data, therefore the rivers must have a larger buffer value that the other layers.

\subsubsection{Overzooming}\label{overzooming}
The min- and maxzoom values define on which zoom levels there is data. This does not mean that it is not possible to zoom deeper in that the maxzoom value.
Overzooming defines to term of displaying data at higher zoom levels.\footnote{\url{https://www.mapbox.com/help/source-manual/\#overzooming}}
This allows us to show data on higher zoom levels, without generating vector tiles for these zoom levels.
Mapbox has defined a rule of thumb for vector tiles. Vector tiles are useful for about 4-6 levels of overzooming. If I have a vector tile on zoom level 10, it can be stretched out up to zoom level 14 or 16.  

\subsubsection{Layer Ordering}\label{layer_ordering}
The order in which the layer are defined in the data style is equal to the order they are stored in the vector tiles.
The layer at the top of the layer definition will be drawn first next the second layer and so one. So the layer at the bottom is drawn on top of all the other layers. 


\section{Zoom Level Reference}\label{zoomlevel_reference}
The zoom level reference helps to see which feature class is included on which zoom level. The zoom levels are ordered by how they get drawn. The feature class landuse is at the bottom and housenum\_label is on top of all the others. 

% Please add the following required packages to your document preamble:
% \usepackage{graphicx}
\begin{table}[H]
\centering
\resizebox{\textwidth}{!}{%
\begin{tabular}{l|ccccccccccccccc}
 & \multicolumn{1}{l}{z0} & \multicolumn{1}{l}{z1} & \multicolumn{1}{l}{z2} & \multicolumn{1}{l}{z3} & \multicolumn{1}{l}{z4} & \multicolumn{1}{l}{z5} & \multicolumn{1}{l}{z6} & \multicolumn{1}{l}{z7} & \multicolumn{1}{l}{z8} & \multicolumn{1}{l}{z9} & \multicolumn{1}{l}{z10} & \multicolumn{1}{l}{z11} & \multicolumn{1}{l}{z12} & \multicolumn{1}{l}{z13} & \multicolumn{1}{l}{z14} \\ \hline
landuse &  &  &  &  &  & x & x & x & x & x & x & x & x & x & x \\
waterway &  &  &  &  &  &  &  &  & x & x & x & x & x & x & x \\
water & x & x & x & x & x & x & x & x & x & x & x & x & x & x & x \\
aeroway &  &  &  &  &  &  &  &  &  &  &  &  & x & x & x \\
barrier\_line &  &  &  &  &  &  &  &  &  &  &  &  &  &  & x \\
building &  &  &  &  &  &  &  &  &  &  &  &  &  & x & x \\
landuse\_overlay &  &  &  &  &  &  &  & x & x & x & x & x & x & x & x \\
tunnel &  &  &  &  &  &  &  &  &  &  &  & x & x & x & x \\
road &  &  &  &  &  & x & x & x & x & x & x & x & x & x & x \\
bridge &  &  &  &  &  &  &  &  &  &  &  &  & x & x & x \\
admin & x & x & x & x & x & x & x & x & x & x & x & x & x & x & x \\
country\_label &  & x & x & x & x & x & x & x & x & x & x & x & x & x & x \\
marine\_label &  & x & x & x & x & x & x & x & x & x & x & x & x & x & x \\
state\_label &  &  &  &  & x & x & x & x & x & x & x & x & x & x & x \\
place\_label &  &  &  &  & x & x & x & x & x & x & x & x & x & x & x \\
water\_label &  &  &  &  &  &  &  &  &  &  & x & x & x & x & x \\
poi\_label &  &  &  &  &  &  &  &  &  &  &  &  &  &  & x \\
road\_label &  &  &  &  &  &  &  &  & x & x & x & x & x & x & x \\
waterway\_label &  &  &  &  &  &  &  &  & x & x & x & x & x & x & x \\
housenum\_label &  &  &  &  &  &  &  &  &  &  &  &  &  &  & x
\end{tabular}
}
\caption{Shows which feature class is included on which zoom level}
\label{my-label}
\end{table}

\section{Reverse Engineering Process}\label{reverse_engineering_process}
One of the main requirements of this project was to make our vector tiles compatible with the Mapbox Streets vector tiles\footnote{\url{https://www.mapbox.com/developers/vector-tiles/mapbox-streets-v6/}}.

We didn't define this requirement from the beginning, it just evolved during the construction of our first prototype.
Therefore we spent a lot of time making our vector tiles as similar as possible to the ones of Mapbox.

The sections below describe the tools and methods we used to achieve the goal of Mapbox Streets compatibility.

\subsection{Vector Tile Format}\label{vector_tile_format}
To better understand what the vector tile compare tool does, we will give a high level introduction to the vector tiles format.

A vector tile can consist of one or more named layers and containing one or more features. A feature consist of attributes and a geometry (point, linestring or polygon). Attributes are represented as a dictionary of key, value pairs. 

Below you can find an example vector tile, which has two layers water and admin. The water layer has the attribute key "osm\_id" and value 0. If you would compare this example with the specification\footnote{\url{https://github.com/mapbox/vector-tile-spec/tree/master/1.0.1}}, one could think this is not a specification conform vector tile. The example below is a compressed vector tile. More information on what compression methods are applied can be found in the specification. 

Mapbox Streets v6 vector tile(0/0/0):
\begin{jsoncode}
{ 
  "layers": {
    "water": {
      "version": 1,
      "name": "water",
      "extent": 4096,
      "length": 18,
      "_pbf": {
        "buf": [26,143,32,10,5,119,97,1],
        "pos": 51410,
        "length": 51410
      },
      "_keys": ["osm_id"],
      "_values": [0],
      "_features": [11,3474,3499,3530,3561,3584] 
    },
    "admin": {
      "version": 1,
      "name": "admin",
      "extent": 4096,
      "length": 1447,
      "_pbf": {
        "buf": [26,143,32,10,5,1],
        "pos":51410,
        "length":51410
       },
      "_keys": ["admin_level","disputed","iso_3166_1","maritime"],
      "_values": [2,0,"FR",1],
      "_features": [4126,4152,4377,4403,4429,4455,4481,4507,4533]
    }
  } 
}
\end{jsoncode}


\section{Database Schema}

Implementation details of the database schema.

\subsubsection{OSM id}
All tables and views that are derived from \osm{} data have keep the original id\footnote{\url{https://wiki.openstreetmap.org/wiki/64-bit_Identifiers}}
to trace back the data and be able to query a distinct \osm{} feature in a visual style.

\subsubsection{Translations}
All features that will get a label layer will contain several translations.
The translations are directly mapped from the suffixed language code \footnote{\url{https://wiki.openstreetmap.org/wiki/Key:name}}. If a field is not available
in the language the local name is used.

\begin{flushleft}
    \begin{tabular}{ll}
    \hline
     Field    & 	Description                                    \\
    \hline
    name      & Local name  \\
    name\_en	 & English                          \\
    name\_es	 & Spanish                          \\
    name\_fr	 & French                           \\
    name\_de	 & German                           \\
    name\_ru	 & Russian                          \\
    name\_zh	 & Chinese                          \\
    \end{tabular}
\end{flushleft}

\subsubsection{Type and Class}
The class can be explained as a feature class. It is a categorization of a OSM value.
The type is the OSM value of the feature.

\section{Classification}
\label{classification}

The OpenStreetMap tagging schema has developed into a complex taxonomy of real-world feature classes and objects. \cite[p. 15]{haklay2008openstreetmap}. Map designers don't want to design
for each distinct object specifically which is why Mapbox and others abstract distinct key value pairs into so called feature classes.

Mapbox calls those feature class simply class.

Mapping created key value pairs into categories cannot be automated
and there is no standard. This is why we have done it by hand.

A map designer that wants to style agricultural areas does not care
what type of field it is.

\begin{flushleft}
\begin{tabular}{llll}
Key      & Value      & Class       & Type           \\
\hline
landuse  & farm       & agriculture & orchard        \\
building & farm       & agriculture & farm           \\
landuse  & farmland   & agriculture & farmland       \\
landuse  & farmyard   & agriculture & farmyard       \\
landuse  & allotments & agriculture & allotments     \\
landuse  & vineyard   & agriculture & vineyard       \\
landuse  & vineyard   & agriculture & plant\_nursery
\end{tabular}
\end{flushleft}

\subsection{Classification Format}

We created the classifications in a YAML based format.
Where each key in \texttt{classifications} denotes the classification name. The elements within each classification (e.g. \texttt{driveway} or \texttt{main} are the class name and the values below the class name (e.g. \texttt{primary}, \texttt{primary\_link} the OSM values to match. We do not explicitly match the OSM keys as well - only the values.

\begin{yamlcode}
classifications:
  road:
    highway:
    - motorway
    - motorway_link
    - driveway
    main:
    - primary
    - primary_link
    - trunk
    - trunk_link
    - secondary
    - secondary_link
    - tertiary
    - tertiary_link
\end{yamlcode}

\subsection{Code Generation}

We take the readable classification format and generate immutable SQL
functions we can use in our queries.
The example above will result in the following function.

\begin{sqlcode}
CREATE OR REPLACE FUNCTION classify_road(type VARCHAR)
RETURNS VARCHAR AS $$
  BEGIN
    RETURN CASE
      WHEN type IN ('motorway','motorway_link','driveway') THEN 'highway'
      WHEN type IN ('primary','primary_link',
                    'trunk','trunk_link',
                    'secondary','secondary_link',
                    'tertiary','tertiary_link') THEN 'main'
    END;
  END;
$$ LANGUAGE plpgsql IMMUTABLE;
\end{sqlcode}

Classifications are then baked into vector tile attributes
of geometries.

\begin{sqlcode}
SELECT
  geometry,
  classify_road(type) AS class,
  type AS type
FROM osm_roads
\end{sqlcode}


\subsection{Tools}\label{tools}
During the prototyping phase we realized, that we needed build tools which help us track the progress of compatibility.

\subsubsection{Vector Tile Compare}\label{vector_tile_compare}
The vector tile compare tool analyzes vector tiles and outputs interesting information like layers and attributes. We generated this output for the same vector tiles of Mapbox Streets and our own (Open Streets). Next we uploaded the results to a Github repository and used the branch compare feature to compare them. 

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{images/vector_tile_compare.png}
  \caption{Compare of Mapbox Streets v6 and Open Streets on 31.10.2015}
\end{figure}

This gave us a good indicator, which layers are shown on which zoom level and what attributes are contained in a layer.
\subsubsection{Visual Compare}\label{visual_compare}
The vector tile comparison was good to ensure that we have exactly the same data on the same zoom level. But when we started to visually compare our map with the map of Mapbox Streets, we still saw big differences. So we decided to build a visual compare tool. 

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{images/visual_compare.png}
  \caption{Visual Compare of Mapbox Streets and Open Streets}
\end{figure}

The figure below shows a screenshot of the visual compare tool. On the left side is Mapbox Streets and on the right side our Open Streets map. They both use the same visual style (OSM Bright 2\footnote{\url{https://github.com/mapbox/mapbox-studio-osm-bright.tm2}}). When you zoom in on the right side of the map, it automatically zooms in on the right side. This tools was very helpful to find all the differences.

\subsection{Working Methods}
This section describes what we did, when we found a difference. When we identified a difference with the vector compare or visual compare tool, we first checked if the missing data is included in our import mapping. If this was not the case, we used the TagFinder tool\footnote{\url{https://wiki.openstreetmap.org/wiki/TagFinder}} find the right OSM key, value pair of the missing item. Next we included the key, value pair into our import mapping and re-imported the OSM data. At the end the SQL query needs to be altered to fetch the added item. Now the missing item should appear on the map. During this process we used mostly Mapbox Studio Classic\footnote{\url{https://www.mapbox.com/mapbox-studio-classic/}} as the map can be rendered on the fly after the query has been altered.

\section{PostgreSQL Performance}
\label{postgres-performance}

The most intensive work is done on the database side to respond to all SQL queries
made by Mapnik in the fastest way possible.

\subsection{Tuning}

The PostgreSQL default parameters do not deliver good performance for stronger machines\footnote{\url{https://wiki.postgresql.org/wiki/Tuning_Your_PostgreSQL_Server}-}
For the different database machines PgTune\footnote{\url{http://pgtune.leopard.in.ua/}} calculator has been used to determine good cache and buffer sizes for data warehouse style computing.

Example configuration for a host with 50 GB of memory.

\begin{bashcode}
max_connections = 20
shared_buffers = 12800MB
effective_cache_size = 38400MB
work_mem = 320MB
maintenance_work_mem = 2GB
checkpoint_segments = 128
checkpoint_completion_target = 0.9
wal_buffers = 16MB
default_statistics_target = 500
\end{bashcode}

For speed up importing we disabled transactional features of PostgreSQL. \footnote{\url{http://www.databasesoup.com/2015/02/running-with-scissors-mode.html}}.

\begin{bashcode}
bgwriter_lru_maxpages = 0
wal_level = minimal
fsync = off
synchronous_commit = off
full_page_writes = off
wal_log_hints = off
\end{bashcode}

\subsection{Indizes}

We use clustered indizes on the geometries to provide fast tile lookup.
TODO: More details

\section{Relative Importance}
\label{localrank}

To reduce label density on lower zoom levels but still contain all data in e.g. zoom level 14 the \texttt{localrank} attribute indiciates how
important a label is compared to the labels in its neighbourhood.

\subsection{Calculating Rank}

\subsubsection{Order Features by their Types}

In the best case scenario a function would rank each point of interest class.
Due to limited time we only explicitly ranked the most important features.

\begin{sqlcode}
CREATE OR REPLACE FUNCTION localrank_poi(type VARCHAR) RETURNS INTEGER
AS $$
BEGIN
  RETURN CASE
    WHEN type IN ('station', 'subway_entrance', 'park',
                  'cemetery', 'bank', 'supermarket', 'car',
                  'library', 'university', 'college', 'police',
                  'townhall', 'courthouse') THEN 2
    WHEN type IN ('nature_reserve', 'garden', 'public_building') THEN 3
    WHEN type IN ('stadium') THEN 90
    WHEN type IN ('hospital') THEN 100
    WHEN type IN ('zoo') THEN 200
    WHEN type IN ('university', 'school', 'college', 'kindergarten') THEN 300
    WHEN type IN ('supermarket', 'department_store') THEN 400
    WHEN type IN ('nature_reserve', 'swimming_area') THEN 500
    WHEN type IN ('attraction') THEN 600
    ELSE 1000
  END;
END;
$$ LANGUAGE plpgsql IMMUTABLE;
\end{sqlcode}


\subsubsection{Calculate Rank across Grid}

The rank is calculated across a grid of 128 pixels. The most
important features from the \texttt{localrank\_poi} function will
also be the most relevant POIs.

\begin{sqlcode}
SELECT
  geometry,
  rank() OVER (PARTITION BY LabelGrid(geometry, 128 * !pixel_width!)
               ORDER BY localrank_poi(type) ASC) AS localrank,
FROM osm_poi
\end{sqlcode}

