\chapter{Technology Evaluation}\label{technology_evaluation}

\section{Spatial Database}\label{spatial_database}

PostGIS was the only viable choice due to superbe tooling support. The OSM wiki\footnote{\url{http://wiki.openstreetmap.org/wiki/Databases_and_data_access_APIs\#Database_Schemas}} provides a very helpful article about which import tool or database should be selected for different use cases. For the use case rendering the only possibility they recommend is PostgresSQL with the PostGIS extension. 

\section{OSM Import Tool}\label{osm_import_tool}
The OSM community
recommends\footnote{\url{http://wiki.openstreetmap.org/wiki/Databases_and_data_access_APIs}}
PostgreSQL with the Postgis extension and imposm or osm2pgsql as import tool.

\subsection{Criterias}\label{criterias}

\paragraph{Speed} 
In order to iterate fast and be able to change the data style frequently
it is important that the import tool is reasonably fast and is able
to import the OSM planet file in one single day.

\paragraph{Customized Schema}
Customizing a schema to already split up features into separate tables
makes querying more performant and easier to do.

\paragraph{Diff Updates}
It must be possible to applying Planet diffs \footnote{\url{http://wiki.openstreetmap.org/wiki/Planet.osm/diffs}} 
to continuously update the database with newer data.

If a import is very fast it is also possible to simply reimport the latest
planet dump.

\paragraph{Existing Data Style Projects}
In order to get started it is helpful to have alot of query example
from other data style projects available.

\subsection{Evaluation Matrix}\label{evaluation_matrix}

\begin{center}
    \begin{tabular}{llll}
    \hline
    Criteria         & Weight & imposm & osm2pgsql \\
    \hline
    Speed             & 0,3    & 8      & 5         \\
    Customized Schema & 0,4    & 7      & 4         \\
    Diff Updates      & 0,2    & 6      & 8         \\
    Existing Material & 0,1    & 6      & 10        \\
    \hline
    \textbf{Weighted Score} & 1      & 7      & 5,7       \\
    \end{tabular}
\end{center}


\subsection{osm2pgsql}\label{osm2pgsql_importer}

osm2pgsql \footnote{\url{http://wiki.openstreetmap.org/wiki/Osm2pgsql}} is the
most commonly used import tool for processing raw OpenStreetMap data into PostGIS.
The import schema is also called osm2pgsql and defines a very
simple schema(line, point, polygon and
roads)\footnote{\url{http://wiki.openstreetmap.org/wiki/Osm2pgsql/schema}}.
This results in very large tables, so it is recommended to create good
indices. Osm2pgsql supports updating of the database, if the values have
been stored as hstore.

The schema can be adapted via the import style \footnote{\url{http://wiki.openstreetmap.org/wiki/Osm2pgsql\#Import_style}}
but most projects use the default style\footnote{\url{https://github.com/openstreetmap/osm2pgsql/blob/master/default.style}} provided by osm2pgsql.

For our use case it is important, that the import is efficent and that
the import tool supports updating based on OSM diff files. Imposm 3 is
faster than osm2pgsql and supports updatability. So we decided to take
imposm for importing.

\subsubsection{Imposm 3 }\label{imposm-importer}

Imposm is an import tool for osm data, it is not a schema. But it
defines a default
schema\footnote{\url{http://imposm.org/docs/imposm/latest/database_schema.html}},
which could possibly be changed by provinding a custom mapping file. An
advantage of the default schema is that it groups data thematically into
tables. Which results in smaller tables and simpler queries. Imposm 3
supports updating the database from OSM diff
files\footnote{\url{http://imposm.org/docs/imposm3/latest/tutorial.html\#diff}}

TODO: formulate decision

\section{Vector Tile Format}\label{vector-tile-formats}

Vector tiles is quite a broad term. If we talk about vector tiles in thesis we usually mean Mapbox vector tiles which is just a custom open specification how vector tiles should be structured.

\paragraph{Mapbox Vector Tiles}

When Mapbox introduced it's geography tool Mapbox Studio in 2013 they
created the \emph{Mapbox Vector Tiles Specification}
\footnote{\url{https://github.com/mapbox/vector-tile-spec}} which is
implemented by a variety of tools and clients
\footnote{\url{https://github.com/mapbox/awesome-vector-tiles}}
including \emph{Mapbox GL JS}, \emph{Open Layers 3}, \emph{Leaflet},
\emph{Mapzen Tangram} and Esri
\footnote{\url{https://www.mapbox.com/blog/vector-tile-adoption/}} in
the future.

\paragraph{Geopackage}

The \emph{GeoPackage Encoding Standard} is the OGC counterpart to the
\emph{Mapbox Vector Tiles Specification} which was introduced later and
is supported by QGIS, ESRI and GDAL.

\paragraph{Google Maps}

Google Maps is using vector tiles since 2010 under the hood and was the
first provider implementing this. Styling is limited and the format
proprietary.

TODO: formulate decision

\section{Vector Tile Server}\label{vector_tile_server}

Next to the vector tiles for Switzerland, the second deliverable is a basic vector tile server. So that even a non technical person can get started quickly with our vector tiles.\newline{}
When we did some research on open source projects of vector tile servers, we found out that most of the people build their tile server set-up specifically for their use case. So there wasn't a typical solution present like Postgres is for the spatial databases.

\subsection{Tessera}\label{tessera}

Tessera is basically a Node.js webserver, which uses Mapbox's tilelive\footnote{\url{https://github.com/mapbox/tilelive}} modules to read vector tiles and generate raster tiles of it.
TODO: Add diagramm with architecture
We did load tests to get some metrics on how the server is performing.

Infrastructure: AWS EC2 t2.micro instance(1 GB Memory / 1 Core)
Task: Zooming in from zoom level 10 to 22
Conditions: 50 concurrent users
Results:
\begin{bashcode}
---- Global Information --------------------------------------------------------
> request count                                      10350 (OK=10348  KO=2     )
> min response time                                     50 (OK=50     KO=60010 )
> max response time                                  60335 (OK=56103  KO=60335 )
> mean response time                                  2138 (OK=2127   KO=60172 )
> std deviation                                       3023 (OK=2914   KO=162   )
> response time 50th percentile                       1115 (OK=1114   KO=60172 )
> response time 75th percentile                       3127 (OK=3125   KO=60253 )
> mean requests/sec                                 75.919 (OK=75.904 KO=0.015 )
---- Response Time Distribution ------------------------------------------------
> t < 800 ms                                          4545 ( 44%)
> 800 ms < t < 1200 ms                                 756 (  7%)
> t > 1200 ms                                         5047 ( 49%)
> failed                                                 2 (  0%)
---- Errors --------------------------------------------------------------------
> java.util.concurrent.TimeoutException: Request timed out to ec      2 (100.0%)
2-52-30-184-45.eu-west-1.compute.amazonaws.com/52.30.184.45:80...
\end{bashcode}

With 50 concurrent users tessera was still able to respond to all requests in less than 1200 ms.

\subsection{OpenStreetMap "Standard" tile server}\label{osm_standard_tile_server}
Our adviser Petr Pridal recommended to reimplement the OSM standard raster tile server for the use of vector tiles. The OSM standard raster tile server consists of Apache as webserver and a custom Apache module called mod\_tile\footnote{\url{http://wiki.openstreetmap.org/wiki/Mod_tile}} for the rendering of raster tiles. This is a proven set-up as it is in production since years, but it was designed a long time ago when nobody though about vector tiles.

Petr Pridals proposal was instead of having a geospatial database as datasource like the "old" raster tile server, switching the datasource to vector tiles. The task would have been to implement a custom Apache module which reads the vector tiles, renders them with mapnik and provides them to the apache webserver.

\subsection{Decision}\label{tile_server_decision}
The plan was to perform the load test on each version of the vector tile server and then make the decision based on the results. Due to the fact, that the test results of tessera where good enough for our use case and we didn't have to implement a lot, we decided to take tessera as vector tile server.
If somebody needs a high-performance tile server, one should probably think about the second variant.
